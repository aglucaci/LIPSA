"""

Snakemakefile that runs the AOC application - Selection analysis.

Written by Alexander G Lucaci (2024)

"""

# =============================================================================
# Imports
# =============================================================================

import itertools
import os
import sys
import csv
import json
from pathlib import Path
from snakemake.utils import min_version
import glob

# =============================================================================
# Configuration
# =============================================================================

configfile: 'config.yml'

with open("cluster.json", "r") as fh:
  cluster = json.load(fh)
#end with

Label = config["Label"]

# Set output directory
BASEDIR = os.getcwd()

# Set output directory
BASEDIR = os.getcwd()

print("# We are operating out of base directory:", BASEDIR)

OUTDIR = os.path.join(BASEDIR, "results", Label)

print("# Output directory:", OUTDIR)

# GnathoBCL6.fasta

Recombinants       = ['GnathoBCL6.RDP.fasta']

DATADIR = os.path.join(BASEDIR,
                       "data",
                       Label)
                       
CladeLabels = sorted([x for x in glob.glob(os.path.join(OUTDIR, '*.clade'))])

ReferenceClade = os.path.basename(CladeLabels[0]).split(".")[0] 

print("# We will process selection analyses in", len(Recombinants), "files")
print("# We will use the following clade labels:", CladeLabels)
print("# Reference clade:", ReferenceClade)

# Set PPN
PPN = cluster["__default__"]["ppn"]

# HyPhy settings
HYPHY = "hyphy"
HYPHYMPI = "HYPHYMPI"

FITMG94 = os.path.join(BASEDIR, "hyphy-analyses", "FitMG94", "FitMG94.bf")

MPICMD = "mpirun --use-hwthread-cpus"

# =============================================================================
# Rule all
# =============================================================================

rule all:
    input:
        # Calculate genetic distances
        expand(os.path.join(OUTDIR, "{sample}.dst"), sample = Recombinants),
        # Tree inference
        expand(os.path.join(OUTDIR, "{sample}.treefile"), sample = Recombinants),
        # Selection analysis repertoire
        expand(os.path.join(OUTDIR, "{sample}.MG94.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.FEL.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.FUBAR.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.BUSTEDS.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.MEME.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.ABSREL.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.SLAC.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.BGM.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.PRIME.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.ABSREL-MH.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.BUSTEDS-MH.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.FMM.json"), sample=Recombinants),
        # Labelling taxonomy
        expand(os.path.join(OUTDIR, "{sample}.treefile.labelled"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.RELAX.json"), sample=Recombinants),
        expand(os.path.join(OUTDIR, "{sample}.CFEL.json"), sample=Recombinants),
        # Executive Summary
        #expand(os.path.join(OUTDIR, "{sample}.FEL.png"), sample=Recombinants), # Start summary of results
        #expand(os.path.join(OUTDIR, "{sample}.FEL.csv"), sample=Recombinants),
        #expand(os.path.join(OUTDIR, "{sample}.FEL.FigureLegend.txt"), sample=Recombinants),
        #expand(os.path.join(OUTDIR, "{sample}.cumulativeResults.csv"), sample=Recombinants)
        # Executive Summary
        expand(os.path.join(OUTDIR, "{sample}.executiveSummary.csv"), sample=Recombinants)
    #end input
#end rule all

# =============================================================================
# Rules
# =============================================================================

rule tn93:
    input:
       input = os.path.join(OUTDIR, "{sample}")
    output:
       output = os.path.join(OUTDIR, "{sample}.dst")
    shell:
       "tn93 -t 1 -o {output.output} {input.input}"
#end rule tn93

# =============================================================================
# IQ-TREE for ML tree inference
# =============================================================================

#rule fasttree:
#    input:
#        input = os.path.join(OUTDIR, 'RDP', "{sample}")
#    output:
#        tree = os.path.join(OUTDIR, "{sample}.FastTree.treefile")
#    shell:
#        "FastTree -nt -gtr {input.input} > {output.tree}"
#end rule 

rule iqtree: # Unrooted
    input:
        input = os.path.join(OUTDIR, "{sample}")
    output:
        tree = os.path.join(OUTDIR, "{sample}.treefile")
    shell:
        "iqtree -s {input.input} -T AUTO -B 1000"
#end rule iqtree

# =============================================================================
# Selection Analyses
# =============================================================================

rule FITMG94:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree = rules.iqtree.output.tree
    output:
        results = os.path.join(OUTDIR, "{sample}.MG94.json")
    shell: 
        "{HYPHY} {FITMG94} --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --rooted No --lrt Yes --type global --frequencies CF3x4"
#end rule 

rule FEL:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.FEL.json")
    shell: 
        # --use-hwthread-cpus
        # "mpirun -np {PPN} {HYPHYMPI} FEL --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --ci Yes"
        "mpirun --use-hwthread-cpus {HYPHYMPI} FEL --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --ci Yes"
#end rule 

rule FUBAR:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.FUBAR.json")
    shell: 
        "{MPICMD} {HYPHYMPI} FUBAR --alignment {input.codon_aln} --tree {input.tree} --output {output.results}"
#end rule 

rule BUSTEDS:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.BUSTEDS.json")
    shell: 
        "mpirun --use-hwthread-cpus {HYPHYMPI} BUSTED --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --srv Yes --starting-points 10"
#end rule

rule MEME:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.MEME.json")
    shell: 
        "mpirun --use-hwthread-cpus {HYPHYMPI} MEME --alignment {input.codon_aln} --tree {input.tree} --output {output.results}"
#end rule 

rule ABSREL:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.ABSREL.json")
    shell: 
        "{MPICMD} {HYPHYMPI} ABSREL --alignment {input.codon_aln} --tree {input.tree} --output {output.results}"
#end rule

rule SLAC:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.SLAC.json")
    shell: 
        "{MPICMD} {HYPHYMPI} SLAC --alignment {input.codon_aln} --tree {input.tree} --output {output.results}"
#end rule 

rule BGM:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.BGM.json")
    shell: 
        "{HYPHY} BGM --alignment {input.codon_aln} --tree {input.tree} --output {output.results}"
#end rule 

rule PRIME:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.PRIME.json")
    shell: 
        "{MPICMD} {HYPHYMPI} PRIME --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --impute-states Yes"
#end rule 

rule ABSRELMH:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.ABSREL-MH.json")
    shell: 
        "{MPICMD} {HYPHYMPI} ABSREL --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --multiple-hits Double+Triple"
#end rule 

rule BUSTEDSMH:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.BUSTEDS-MH.json")
    shell: 
        "mpirun --use-hwthread-cpus {HYPHYMPI} BUSTED --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --srv Yes --multiple-hits Double+Triple --starting-points 10"
#end rule

rule FMM:
    input: 
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.iqtree.output.tree
    output: 
        results = os.path.join(OUTDIR, "{sample}.FMM.json")
    shell:
        "{MPICMD} {HYPHYMPI} FMM --alignment {input.codon_aln} --tree {input.tree} --output {output.results} --triple-islands Yes"
#end rule

# =============================================================================
# Lineages
# =============================================================================

rule AssignLineages:
    input:
        tree   = rules.iqtree.output.tree
    output:
        output  = os.path.join(OUTDIR, "{sample}.treefile.labelled")
    run:
        first_time = True
        for clade_file in CladeLabels:
            print(clade_file, input[0])
            label      = os.path.basename(clade_file).split(".")[0]

            if first_time == True:
                cmd = " ".join([HYPHY,
                                os.path.join(BASEDIR, "scripts", "label-tree.bf"),
                                "--tree", input[0],
                                "--list", clade_file,
                                "--output", output[0],
                                "--label", label])
                first_time = False
            else:
                cmd = " ".join([HYPHY,
                                os.path.join(BASEDIR, "scripts", "label-tree.bf"),
                                "--tree", output[0],
                                "--list", clade_file,
                                "--output", output[0],
                                "--label", label])
            #end if
            print(cmd)
            os.system(cmd)
        #end for
    #end run
#end rule

# =============================================================================
# Group level Selection analyses
# =============================================================================

rule RELAX:
    input:
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.AssignLineages.output.output
    output:
        output = os.path.join(OUTDIR, "{sample}.RELAX.json")
    params:
        RefClade = ReferenceClade
    shell:
        "{HYPHY} RELAX --alignment {input.codon_aln} --tree {input.tree} --output {output.output} --reference-group {params.RefClade} --models All --mode 'Group mode' --starting-points 10 --srv Yes"
#end rule

rule CFEL:
    input:
        codon_aln = os.path.join(OUTDIR, "{sample}"),
        tree      = rules.AssignLineages.output.output
    output:
        output = os.path.join(OUTDIR, "{sample}.CFEL.json")
    params:
        RefClade = ReferenceClade
    shell:
        "{HYPHY} contrast-fel --alignment {input.codon_aln} --tree {input.tree} --output {output.output} --branch-set {params.RefClade}"
#end rule

# =============================================================================
# Summarize results 
# =============================================================================

rule executiveSummary:
    input:
        inputFEL   = rules.FEL.output.results,
        inputFUBAR = rules.FUBAR.output.results,
        inputMEME = rules.MEME.output.results,
        inputBUSTEDS = rules.BUSTEDS.output.results,
        inputBUSTEDSMH = rules.BUSTEDSMH.output.results,
        inputBGM = rules.BGM.output.results,
        inputABSREL = rules.ABSREL.output.results,
        inputSLAC = rules.SLAC.output.results,
        inputRELAX = rules.RELAX.output.output,
        inputCFEL = rules.CFEL.output.output
    output:
        output = os.path.join(OUTDIR, "{sample}.executiveSummary.csv")
    script:
        "scripts/executiveSummary.py"
#end rule

"""
rule executiveSummaryFEL:
    input:
        input = rules.FEL.output.results
    params:
        method = "FEL"
    output:
        output = os.path.join(OUTDIR, "{sample}.executiveSummary.csv")
    script:
        "scripts/executiveSummary.py"
#end rule



rule executiveSummaryFUBAR:
    input:
        input = rules.FUBAR.output.results
    params:
        method = "FUBAR"
    output:
        output = os.path.join(OUTDIR, "{sample}.executiveSummary.csv")
    script:
        "scripts/executiveSummary.py"
#end rule
"""

"""
rule executiveSummaryFEL:
    input:
        FEL_JSON = rules.FEL.output.results
    params:
        METHOD = "FEL"
    output:
        output_png    = os.path.join(OUTDIR, "{sample}.FEL.png"),
        output_csv    = os.path.join(OUTDIR, "{sample}.FEL.csv"),
        figure_legend = os.path.join(OUTDIR, "{sample}.FEL.FigureLegend.txt"),
        cumulative_results = os.path.join(OUTDIR, "{sample}.cumulativeResults.csv")
    notebook:
        "notebooks/executiveSummary.ipynb"
#end rule

"""

"""
rule FEL_figures:
    input:
        input = rules.FEL.output.results
    output:
        output_png    = os.path.join(OUTDIR, "{sample}.FEL.png"),
        output_csv    = os.path.join(OUTDIR, "{sample}.FEL.csv"),
        figure_legend = os.path.join(OUTDIR, "{sample}.FEL.txt")
    notebook:
        "notebooks/PipelineSummarizeFEL.ipynb"
"""

# =============================================================================
# End of file
# =============================================================================
